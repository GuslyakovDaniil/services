Проект:
todo-api:

package org.example.todoapi.controllers;

import org.example.todoapi.dto.CategoryDTOs;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.annotation.RequestBody;

@Tag(name = "categories")
@ApiResponses({
@ApiResponse(responseCode = "200", description = "Успешная обработка запроса"),
@ApiResponse(responseCode = "400", description = "Ошибка валидации"),
@ApiResponse(responseCode = "404", description = "Ресурс не найден"),
@ApiResponse(responseCode = "500", description = "Внутренняя ошибка сервера")
})
public interface CategoryApi {
@Operation(summary = "Создать категорию")
@PostMapping(value = "/api/categories", produces = MediaType.APPLICATION_JSON_VALUE)
CategoryDTOs.CategoryResponse createCategory(@Valid @RequestBody CategoryDTOs.CategoryRequest request);

@Operation(summary = "Получить категорию по ID")
@GetMapping(value = "/api/categories/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
CategoryDTOs.CategoryResponse getCategory(@PathVariable("id") Long id);

@Operation(summary = "Обновить категорию")
@PutMapping(value = "/api/categories/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
CategoryDTOs.CategoryResponse updateCategory(@PathVariable("id") Long id, @Valid @RequestBody CategoryDTOs.CategoryRequest request);

@Operation(summary = "Удалить категорию")
@DeleteMapping(value = "/api/categories/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
void deleteCategory(@PathVariable("id") Long id);

@Operation(summary = "Получить все категории")
@GetMapping(value = "/api/categories", produces = MediaType.APPLICATION_JSON_VALUE)
java.util.List<CategoryDTOs.CategoryResponse> getCategories();
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;
import org.example.todoapi.dto.CategoryDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@RestController
public class CategoryController implements CategoryApi {

private final List<CategoryDTOs.CategoryResponse> categories = new ArrayList<>();
private long idCounter = 0;

@Override
public CategoryDTOs.CategoryResponse createCategory(CategoryDTOs.CategoryRequest request) {
    if (request == null || request.name() == null || request.name().isBlank()) {
        throw new InvalidArgumentException("Category name cannot be empty");
    }
    var response = new CategoryDTOs.CategoryResponse(++idCounter, request.name());
    categories.add(response);
    return response;
}

@Override
public CategoryDTOs.CategoryResponse getCategory(Long id) {
    return categories.stream()
            .filter(category -> Objects.equals(category.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found category with id: " + id));
}

@Override
public CategoryDTOs.CategoryResponse updateCategory(Long id, CategoryDTOs.CategoryRequest request) {
    if (request == null || request.name() == null || request.name().isBlank()) {
        throw new InvalidArgumentException("Category name cannot be empty");
    }
    var category =  categories.stream()
            .filter(c -> Objects.equals(c.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found category with id: " + id));
    categories.remove(category);
    var updateCategory = new CategoryDTOs.CategoryResponse(id, request.name());
    categories.add(updateCategory);
    return updateCategory;
}


@Override
public void deleteCategory(Long id) {
    var category =  categories.stream()
            .filter(c -> Objects.equals(c.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found category with id: " + id));
    categories.remove(category);
}

@Override
public List<CategoryDTOs.CategoryResponse> getCategories() {
    return categories;
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.OrderDTOs;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@Tag(name = "orders")
@ApiResponses({
@ApiResponse(responseCode = "200", description = "Успешная обработка запроса"),
@ApiResponse(responseCode = "400", description = "Ошибка валидации"),
@ApiResponse(responseCode = "404", description = "Ресурс не найден"),
@ApiResponse(responseCode = "500", description = "Внутренняя ошибка сервера")
})
public interface OrderApi {
@Operation(summary = "Создать заказ")
@PostMapping(value = "/api/orders", produces = MediaType.APPLICATION_JSON_VALUE)
OrderDTOs.OrderResponse createOrder(@Valid @RequestBody OrderDTOs.OrderRequest request);

@Operation(summary = "Получить заказ по ID")
@GetMapping(value = "/api/orders/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
OrderDTOs.OrderResponse getOrder(@PathVariable("id") Long id);

@Operation(summary = "Обновить заказ")
@PutMapping(value = "/api/orders/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
OrderDTOs.OrderResponse updateOrder(@PathVariable("id") Long id, @Valid @RequestBody OrderDTOs.OrderRequest request);

@Operation(summary = "Удалить заказ")
@DeleteMapping(value = "/api/orders/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
void deleteOrder(@PathVariable("id") Long id);
@Operation(summary = "Получить все заказы")
@GetMapping(value = "/api/orders", produces = MediaType.APPLICATION_JSON_VALUE)
java.util.List<OrderDTOs.OrderResponse> getOrders();
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.OrderDTOs;
import org.example.todoapi.dto.ProductDTOs;
import org.example.todoapi.dto.UserDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@RestController
public class OrderController implements OrderApi {

private final List<OrderDTOs.OrderResponse> orders = new ArrayList<>();
private final List<UserDTOs.UserResponse> users = new ArrayList<>();
private final List<ProductDTOs.ProductResponse> products = new ArrayList<>();
private long idCounter = 0;


@Override
public OrderDTOs.OrderResponse createOrder(OrderDTOs.OrderRequest request) {
    if (request == null || request.userId() == null || request.productIds() == null || request.productIds().isEmpty() || request.orderDate() == null) {
        throw new InvalidArgumentException("Invalid order data");
    }

    var user = users.stream()
            .filter(u -> Objects.equals(u.id(), request.userId()))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found user with id: " + request.userId()));
    List<ProductDTOs.ProductResponse> productResponses = products.stream()
            .filter(p -> request.productIds().contains(p.id()))
            .collect(Collectors.toList());
    if (productResponses.size() != request.productIds().size()){
        throw new NotFoundException("One or more products not found");
    }
    var response = new OrderDTOs.OrderResponse(
            ++idCounter,
            user,
            productResponses,
            request.orderDate()
    );
    orders.add(response);
    return response;
}

@Override
public OrderDTOs.OrderResponse getOrder(Long id) {
    return orders.stream()
            .filter(order -> Objects.equals(order.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found order with id: " + id));
}


@Override
public OrderDTOs.OrderResponse updateOrder(Long id, OrderDTOs.OrderRequest request) {
    if (request == null || request.userId() == null || request.productIds() == null || request.productIds().isEmpty() || request.orderDate() == null) {
        throw new InvalidArgumentException("Invalid order data");
    }
    var order = orders.stream()
            .filter(o -> Objects.equals(o.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found order with id: " + id));
    var user = users.stream()
            .filter(u -> Objects.equals(u.id(), request.userId()))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found user with id: " + request.userId()));
    List<ProductDTOs.ProductResponse> productResponses = products.stream()
            .filter(p -> request.productIds().contains(p.id()))
            .collect(Collectors.toList());
    if (productResponses.size() != request.productIds().size()){
        throw new NotFoundException("One or more products not found");
    }
    orders.remove(order);
    var updateOrder = new OrderDTOs.OrderResponse(
            id,
            user,
            productResponses,
            request.orderDate()
    );
    orders.add(updateOrder);
    return updateOrder;
}

@Override
public void deleteOrder(Long id) {
    var order = orders.stream()
            .filter(o -> Objects.equals(o.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found order with id: " + id));
    orders.remove(order);
}
@Override
public List<OrderDTOs.OrderResponse> getOrders() {
    return orders;
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.ProductDTOs;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@Tag(name = "products")
@ApiResponses({
@ApiResponse(responseCode = "200", description = "Успешная обработка запроса"),
@ApiResponse(responseCode = "400", description = "Ошибка валидации"),
@ApiResponse(responseCode = "404", description = "Ресурс не найден"),
@ApiResponse(responseCode = "500", description = "Внутренняя ошибка сервера")
})
public interface ProductApi {
@Operation(summary = "Создать продукт")
@PostMapping(value = "/api/products", produces = MediaType.APPLICATION_JSON_VALUE)
ProductDTOs.ProductResponse createProduct(@Valid @RequestBody ProductDTOs.ProductRequest request);

@Operation(summary = "Получить продукт по ID")
@GetMapping(value = "/api/products/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
ProductDTOs.ProductResponse getProduct(@PathVariable("id") Long id);

@Operation(summary = "Обновить продукт")
@PutMapping(value = "/api/products/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
ProductDTOs.ProductResponse updateProduct(@PathVariable("id") Long id, @Valid @RequestBody ProductDTOs.ProductRequest request);

@Operation(summary = "Удалить продукт")
@DeleteMapping(value = "/api/products/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
void deleteProduct(@PathVariable("id") Long id);
@Operation(summary = "Получить все продукты")
@GetMapping(value = "/api/products", produces = MediaType.APPLICATION_JSON_VALUE)
java.util.List<ProductDTOs.ProductResponse> getProducts();
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.ProductDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@RestController
public class ProductController implements ProductApi {

private final List<ProductDTOs.ProductResponse> products = new ArrayList<>();
private long idCounter = 0;

@Override
public ProductDTOs.ProductResponse createProduct(ProductDTOs.ProductRequest request) {
    if (request == null || request.name() == null || request.name().isBlank() || request.price() == null || request.price() <= 0) {
        throw new InvalidArgumentException("Invalid product data");
    }
    var response = new ProductDTOs.ProductResponse(++idCounter, request.name(), request.price());
    products.add(response);
    return response;
}

@Override
public ProductDTOs.ProductResponse getProduct(Long id) {
    return products.stream()
            .filter(product -> Objects.equals(product.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found product with id: " + id));

}

@Override
public ProductDTOs.ProductResponse updateProduct(Long id, ProductDTOs.ProductRequest request) {
    if (request == null || request.name() == null || request.name().isBlank() || request.price() == null || request.price() <= 0) {
        throw new InvalidArgumentException("Invalid product data");
    }
    var product = products.stream()
            .filter(p -> Objects.equals(p.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found product with id: " + id));
    products.remove(product);
    var updateProduct = new ProductDTOs.ProductResponse(id, request.name(), request.price());
    products.add(updateProduct);
    return updateProduct;
}

@Override
public void deleteProduct(Long id) {
    var product = products.stream()
            .filter(p -> Objects.equals(p.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found product with id: " + id));
    products.remove(product);
}
@Override
public List<ProductDTOs.ProductResponse> getProducts() {
    return products;
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.UserDTOs;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@Tag(name = "users")
@ApiResponses({
@ApiResponse(responseCode = "200", description = "Успешная обработка запроса"),
@ApiResponse(responseCode = "400", description = "Ошибка валидации"),
@ApiResponse(responseCode = "404", description = "Ресурс не найден"),
@ApiResponse(responseCode = "500", description = "Внутренняя ошибка сервера")
})
public interface UserApi {
@Operation(summary = "Создать пользователя")
@PostMapping(value = "/api/users", produces = MediaType.APPLICATION_JSON_VALUE)
UserDTOs.UserResponse createUser(@Valid @RequestBody UserDTOs.UserRequest request);

@Operation(summary = "Получить пользователя по ID")
@GetMapping(value = "/api/users/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
UserDTOs.UserResponse getUser(@PathVariable("id") Long id);

@Operation(summary = "Обновить пользователя")
@PutMapping(value = "/api/users/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
UserDTOs.UserResponse updateUser(@PathVariable("id") Long id, @Valid @RequestBody UserDTOs.UserRequest request);

@Operation(summary = "Удалить пользователя")
@DeleteMapping(value = "/api/users/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
void deleteUser(@PathVariable("id") Long id);
@Operation(summary = "Получить всех пользователей")
@GetMapping(value = "/api/users", produces = MediaType.APPLICATION_JSON_VALUE)
java.util.List<UserDTOs.UserResponse> getUsers();
content_copy
download
 Use code with caution.

}
package org.example.todoapi.controllers;

import org.example.todoapi.dto.UserDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@RestController
public class UserController implements UserApi {
private final List<UserDTOs.UserResponse> users = new ArrayList<>();
private long idCounter = 0;

@Override
public UserDTOs.UserResponse createUser(UserDTOs.UserRequest request) {
    if (request == null || request.firstName() == null || request.firstName().isBlank() ||
            request.lastName() == null || request.lastName().isBlank() ||
            request.email() == null || request.email().isBlank() ||
            request.phone() == null || request.phone().isBlank()) {
        throw new InvalidArgumentException("Invalid user data");
    }
    var response = new UserDTOs.UserResponse(
            ++idCounter,
            request.firstName(),
            request.lastName(),
            request.email(),
            request.phone()
    );
    users.add(response);
    return response;
}


@Override
public UserDTOs.UserResponse getUser(Long id) {
    return users.stream()
            .filter(user -> Objects.equals(user.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found user with id: " + id));
}


@Override
public UserDTOs.UserResponse updateUser(Long id, UserDTOs.UserRequest request) {
    if (request == null || request.firstName() == null || request.firstName().isBlank() ||
            request.lastName() == null || request.lastName().isBlank() ||
            request.email() == null || request.email().isBlank() ||
            request.phone() == null || request.phone().isBlank()) {
        throw new InvalidArgumentException("Invalid user data");
    }
    var user = users.stream()
            .filter(p -> Objects.equals(p.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found user with id: " + id));
    users.remove(user);
    var updateuser = new UserDTOs.UserResponse(
            id,
            request.firstName(),
            request.lastName(),
            request.email(),
            request.phone()
    );
    users.add(updateuser);
    return updateuser;
}


@Override
public void deleteUser(Long id) {
    var user = users.stream()
            .filter(p -> Objects.equals(p.id(), id))
            .findFirst()
            .orElseThrow(() -> new NotFoundException("Could not found user with id: " + id));
    users.remove(user);
}


@Override
public List<UserDTOs.UserResponse> getUsers() {
    return users;
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

public class CategoryDTOs {
public record CategoryRequest(
@NotBlank(message = "Name cannot be blank")
@Size(max = 255, message = "Name must be less than 255 characters")
String name
) {}

public record CategoryResponse(
        Long id,
        String name
){}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;
import java.util.List;

public class OrderDTOs {
public record OrderRequest(
@NotNull(message = "User ID cannot be null")
Long userId,
@NotEmpty(message = "Product IDs list cannot be empty")
List<Long> productIds,
@PastOrPresent(message = "Order date should be in past or present")
LocalDate orderDate
) {}

public record OrderResponse(
        Long id,
        UserDTOs.UserResponse user,
        List<ProductDTOs.ProductResponse> products,
        LocalDate orderDate
) {}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.dto;

import jakarta.validation.constraints.*;

public class ProductDTOs {
public record ProductRequest(
@NotBlank(message = "Name cannot be blank")
@Size(max = 255, message = "Name must be less than 255 characters")
String name,
@NotNull(message = "Price cannot be null")
@DecimalMin(value = "0.01", message = "Price must be greater than 0")
Double price
) {}

public record ProductResponse(
        Long id,
        String name,
        Double price
) {}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class UserDTOs {
public record UserRequest(
@NotBlank(message = "First name cannot be blank")
@Size(max = 255, message = "First name must be less than 255 characters")
String firstName,
@NotBlank(message = "Last name cannot be blank")
@Size(max = 255, message = "Last name must be less than 255 characters")
String lastName,
@NotBlank(message = "Email cannot be blank")
@Email(message = "Email is not valid")
String email,
@NotBlank(message = "Phone cannot be blank")
@Pattern(regexp = "^\d{10}$", message = "Phone must be 10 digits")
String phone
) {}

public record UserResponse(
        Long id,
        String firstName,
        String lastName,
        String email,
        String phone
) {}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.stream.Collectors;

@ControllerAdvice
public class ExceptionHandlers {

private static final String ERROR_STATUS = "error";

@ExceptionHandler(InvalidArgumentException.class)
public ResponseEntity<StatusResponse> handleBadRequestException(InvalidArgumentException e) {
    var status = HttpStatus.BAD_REQUEST;
    return ResponseEntity.status(status).body(new StatusResponse(ERROR_STATUS, e.getMessage()));
}

@ExceptionHandler(NotFoundException.class)
public ResponseEntity<StatusResponse> handleNotFoundException(NotFoundException e){
    var status = HttpStatus.NOT_FOUND;
    return ResponseEntity.status(status).body(new StatusResponse(ERROR_STATUS,e.getMessage()));
}

@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<StatusResponse> handleValidationException(MethodArgumentNotValidException e){
    var status = HttpStatus.BAD_REQUEST;
    var errors = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getDefaultMessage())
            .collect(Collectors.joining(", "));
    return ResponseEntity.status(status).body(new StatusResponse(ERROR_STATUS, "Validation error: " + errors));
}

@ExceptionHandler(Exception.class)
public ResponseEntity<StatusResponse> handleInternalServerError(Exception e){
    var status = HttpStatus.INTERNAL_SERVER_ERROR;
    return ResponseEntity.status(status).body(new StatusResponse(ERROR_STATUS, "Internal server error: " + e.getMessage()));
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.exception;

public class InvalidArgumentException extends RuntimeException {

public InvalidArgumentException(String message) {
    super("invalid request: " + message);
}
content_copy
download
 Use code with caution.

}
package org.example.todoapi.exception;

public class NotFoundException extends RuntimeException {
public NotFoundException(String message) {
super("Resource not found: " + message);
}
}
package org.example.todoapi.exception;

public record StatusResponse(String status, String message) {}
package org.example.todoapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodoApiApplication {
public static void main(String[] args) {
SpringApplication.run(TodoApiApplication.class, args);
}
}
application.properties:
server.port=8081

pom.xml:

<?xml version="1.0" encoding="UTF-8"?>


<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>

<groupId>org.example.todoapi</groupId>
<artifactId>todo-api</artifactId>
<version>1.0-SNAPSHOT</version>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-boot-starter</artifactId>
        <version>3.0.0</version>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-boot-starter</artifactId>
        <version>3.0.0</version>
        <exclusions>
            <exclusion>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
<properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
</properties>
content_copy
download
 Use code with caution.
</project>

todo-app:

package com.example.todoapp.assembler;

import com.example.todoapp.controller.CategoryController;
import com.example.todoapp.entity.Category;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelAssembler;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

@Component
public class CategoryAssembler implements RepresentationModelAssembler<Category, EntityModel<Category>> {
    @Override
    public EntityModel<Category> toModel(Category entity) {
        return EntityModel.of(entity,
                linkTo(methodOn(CategoryController.class).getCategory(entity.getId())).withSelfRel(),
                linkTo(methodOn(CategoryController.class).getCategories()).withRel("categories"));
    }

    @Override
    public CollectionModel<EntityModel<Category>> toCollectionModel(Iterable<? extends Category> entities){
        List<EntityModel<Category>> categoryModels = StreamSupport.stream(entities.spliterator(), false)
                .map(this::toModel)
                .collect(Collectors.toList());
        return CollectionModel.of(categoryModels, linkTo(methodOn(CategoryController.class).getCategories()).withSelfRel());
    }
}
package com.example.todoapp.assembler;

import com.example.todoapp.controller.OrderController;
import com.example.todoapp.entity.Order;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelAssembler;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

@Component
public class OrderAssembler implements RepresentationModelAssembler<Order, EntityModel<Order>> {
    @Override
    public EntityModel<Order> toModel(Order entity) {
        return EntityModel.of(entity,
                linkTo(methodOn(OrderController.class).getOrder(entity.getId())).withSelfRel(),
                linkTo(methodOn(OrderController.class).getOrders()).withRel("orders"));
    }
    @Override
    public CollectionModel<EntityModel<Order>> toCollectionModel(Iterable<? extends Order> entities){
        List<EntityModel<Order>> orderModels = StreamSupport.stream(entities.spliterator(), false)
                .map(this::toModel)
                .collect(Collectors.toList());
        return CollectionModel.of(orderModels, linkTo(methodOn(OrderController.class).getOrders()).withSelfRel());
    }
}
package com.example.todoapp.assembler;

import com.example.todoapp.controller.ProductController;
import com.example.todoapp.entity.Product;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelAssembler;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

@Component
public class ProductAssembler implements RepresentationModelAssembler<Product, EntityModel<Product>>{
    @Override
    public EntityModel<Product> toModel(Product entity) {
        return EntityModel.of(entity,
                linkTo(methodOn(ProductController.class).getProduct(entity.getId())).withSelfRel(),
                linkTo(methodOn(ProductController.class).getProducts()).withRel("products"));
    }
    @Override
    public CollectionModel<EntityModel<Product>> toCollectionModel(Iterable<? extends Product> entities){
        List<EntityModel<Product>> productModels = StreamSupport.stream(entities.spliterator(), false)
                .map(this::toModel)
                .collect(Collectors.toList());
        return CollectionModel.of(productModels, linkTo(methodOn(ProductController.class).getProducts()).withSelfRel());
    }
}
package com.example.todoapp.assembler;

import com.example.todoapp.controller.UserController;
import com.example.todoapp.entity.User;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.RepresentationModelAssembler;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;

@Component
public class UserAssembler implements RepresentationModelAssembler<User, EntityModel<User>> {
    @Override
    public EntityModel<User> toModel(User entity) {
        return EntityModel.of(entity,
                linkTo(methodOn(UserController.class).getUser(entity.getId())).withSelfRel(),
                linkTo(methodOn(UserController.class).getUsers()).withRel("users"));
    }
    @Override
    public CollectionModel<EntityModel<User>> toCollectionModel(Iterable<? extends User> entities){
        List<EntityModel<User>> userModels = StreamSupport.stream(entities.spliterator(), false)
                .map(this::toModel)
                .collect(Collectors.toList());
        return CollectionModel.of(userModels, linkTo(methodOn(UserController.class).getUsers()).withSelfRel());
    }
}
package com.example.todoapp.config;

import com.example.todoapp.dto.NotificationDTO;
import com.example.todoapp.service.NotificationService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class MessageConsumer {
    private static final Logger logger = LoggerFactory.getLogger(MessageConsumer.class);
    private final static String queueName = RabbitMQConfig.queueName;
    private final NotificationService notificationService;
    private final ObjectMapper objectMapper;

    @Autowired
    public MessageConsumer(NotificationService notificationService, ObjectMapper objectMapper) {
        this.notificationService = notificationService;
        this.objectMapper = objectMapper;
    }

    @RabbitListener(queues = queueName)
    public void listen(String message) {
        logger.info("Message read from {} : {}", queueName, message);
        try {
            NotificationDTO notificationDTO = objectMapper.readValue(message, NotificationDTO.class);
            logger.info("Deserialized NotificationDTO: {}", notificationDTO);
            notificationService.sendNotification(notificationDTO.toString()); // Отправляем уведомление через NotificationService
        } catch (IOException e) {
            logger.error("Error during deserialization of message from RabbitMQ: {}", message, e);
            notificationService.sendNotification("Error during deserialization of message from RabbitMQ"); // Отправляем сообщение об ошибке через NotificationService
        }
    }
}
package com.example.todoapp.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.AmqpException;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

@Component
public class MessageProducer {
    private static final Logger logger = LoggerFactory.getLogger(MessageProducer.class);
    private final RabbitTemplate rabbitTemplate;
    private final String queueName = RabbitMQConfig.queueName; // Используем константу

    public MessageProducer(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public void sendMessage(String message) {
        logger.debug("Attempting to send message to queue '" + queueName + "': " + message);
        try {
            rabbitTemplate.convertAndSend(queueName, message);
            logger.info("Message successfully sent to queue '" + queueName + "': " + message);
        } catch (AmqpException e) {
            logger.error("Error sending message to queue '" + queueName + "': " + message, e);
        }
    }
}
package com.example.todoapp.config;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {
    public final static String queueName = "firstQueue"; // Имя вашей очереди
    static final String exchangeName = "myExchange"; // Имя вашего exchange

    @Bean
    public Queue myQueue(){
        return new Queue(queueName,false);
    }

    @Bean
    Exchange exchange(){
        return new TopicExchange(exchangeName,false,false);
    }

    @Bean
    Binding binding(Queue queue, Exchange exchange){
        return BindingBuilder.bind(queue).to(exchange).with("my.key").noargs(); // ключ маршрутизации для exchange
    }
}
package com.example.todoapp.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws").setAllowedOriginPatterns("*").withSockJS();
    }
}
package com.example.todoapp.controller;

import org.example.todoapi.controllers.CategoryApi;
import org.example.todoapi.dto.CategoryDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import com.example.todoapp.assembler.CategoryAssembler;
import com.example.todoapp.config.MessageProducer;
import com.example.todoapp.dto.NotificationDTO;
import com.example.todoapp.entity.Category;
import com.example.todoapp.repository.CategoryRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/categories")
public class CategoryController implements CategoryApi {
    private static final Logger logger = LoggerFactory.getLogger(CategoryController.class);
    private final CategoryRepository categoryRepository;
    private final CategoryAssembler categoryAssembler;
    private final MessageProducer messageProducer;
    private final ObjectMapper objectMapper;

    public CategoryController(CategoryRepository categoryRepository,
                              CategoryAssembler categoryAssembler,
                              MessageProducer messageProducer,
                              ObjectMapper objectMapper) {
        this.categoryRepository = categoryRepository;
        this.categoryAssembler = categoryAssembler;
        this.messageProducer = messageProducer;
        this.objectMapper = objectMapper;
    }


    @Override
    public CategoryDTOs.CategoryResponse createCategory(CategoryDTOs.CategoryRequest request) {
        if (request == null || request.name() == null || request.name().isBlank()) {
            throw new InvalidArgumentException("Category name cannot be empty");
        }
        Category category = new Category();
        category.setName(request.name());
        Category savedCategory = categoryRepository.save(category);
        NotificationDTO notificationDTO = new NotificationDTO("Created category with id:", "category", savedCategory.getId(), "create");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        return new CategoryDTOs.CategoryResponse(savedCategory.getId(), savedCategory.getName());
    }

    @Override
    public CategoryDTOs.CategoryResponse getCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found category with id: " + id));
        NotificationDTO notificationDTO = new NotificationDTO("Get category with id:", "category", category.getId(), "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        return new CategoryDTOs.CategoryResponse(category.getId(), category.getName());
    }

    @Override
    public CategoryDTOs.CategoryResponse updateCategory(Long id, CategoryDTOs.CategoryRequest request) {
        if (request == null || request.name() == null || request.name().isBlank()) {
            throw new InvalidArgumentException("Category name cannot be empty");
        }
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found category with id " + id));
        category.setName(request.name());
        Category updatedCategory = categoryRepository.save(category);
        NotificationDTO notificationDTO = new NotificationDTO("Updated category with id:", "category", updatedCategory.getId(), "update");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        return new CategoryDTOs.CategoryResponse(updatedCategory.getId(), updatedCategory.getName());

    }

    @Override
    public void deleteCategory(Long id) {
        if (!categoryRepository.existsById(id)) {
            throw new NotFoundException("Could not found category with id: " + id);
        }
        NotificationDTO notificationDTO = new NotificationDTO("Deleted category with id:", "category", id, "delete");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        categoryRepository.deleteById(id);
    }

    @Override
    public List<CategoryDTOs.CategoryResponse> getCategories() {
        List<Category> categories = categoryRepository.findAll();
        NotificationDTO notificationDTO = new NotificationDTO("Get all categories", "category", null, "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        return categories.stream().map(category -> new CategoryDTOs.CategoryResponse(category.getId(), category.getName())).collect(Collectors.toList());
    }
}
package com.example.todoapp.controller;

import org.example.todoapi.controllers.OrderApi;
import org.example.todoapi.dto.OrderDTOs;
import org.example.todoapi.dto.ProductDTOs;
import org.example.todoapi.dto.UserDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import com.example.todoapp.assembler.OrderAssembler;
import com.example.todoapp.config.MessageProducer;
import com.example.todoapp.dto.NotificationDTO;
import com.example.todoapp.entity.Order;
import com.example.todoapp.entity.Product;
import com.example.todoapp.entity.User;
import com.example.todoapp.repository.OrderRepository;
import com.example.todoapp.repository.ProductRepository;
import com.example.todoapp.repository.UserRepository;
import com.example.todoapp.service.NotificationService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;


@RestController
@RequestMapping("/orders")
public class OrderController implements OrderApi {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);
    private final OrderRepository orderRepository;
    private final OrderAssembler orderAssembler;
    private final UserRepository userRepository;
    private final ProductRepository productRepository;
    private final MessageProducer messageProducer;
    private final ObjectMapper objectMapper;
    private final NotificationService notificationService;

    public OrderController(OrderRepository orderRepository, OrderAssembler orderAssembler,
                           UserRepository userRepository, ProductRepository productRepository,
                           MessageProducer messageProducer, ObjectMapper objectMapper,  NotificationService notificationService) {
        this.orderRepository = orderRepository;
        this.orderAssembler = orderAssembler;
        this.userRepository = userRepository;
        this.productRepository = productRepository;
        this.messageProducer = messageProducer;
        this.objectMapper = objectMapper;
        this.notificationService = notificationService;
    }


    @Override
    public OrderDTOs.OrderResponse createOrder(OrderDTOs.OrderRequest request) {
        if (request == null || request.userId() == null || request.productIds() == null || request.productIds().isEmpty() || request.orderDate() == null) {
            throw new InvalidArgumentException("Invalid order data");
        }
        User user = userRepository.findById(request.userId()).orElseThrow(() -> new NotFoundException("User not found"));
        List<Product> products = productRepository.findAllById(request.productIds());

        if (products.size() != request.productIds().size()) {
            throw new NotFoundException("One or more products not found");
        }
        Order order = new Order();
        order.setUser(user);
        order.setProducts(products);
        order.setOrderDate(request.orderDate());
        Order savedOrder = orderRepository.save(order);

        NotificationDTO notificationDTO = new NotificationDTO("Created order with id:", "order", savedOrder.getId(), "create");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return mapOrderToOrderResponse(savedOrder);
    }


    @Override
    public OrderDTOs.OrderResponse getOrder(Long id) {
        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found order with id: " + id));
        NotificationDTO notificationDTO = new NotificationDTO("Get order with id:", "order", order.getId(), "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return mapOrderToOrderResponse(order);
    }


    @Override
    public OrderDTOs.OrderResponse updateOrder(Long id, OrderDTOs.OrderRequest request) {
        if (request == null || request.userId() == null || request.productIds() == null || request.productIds().isEmpty() || request.orderDate() == null) {
            throw new InvalidArgumentException("Invalid order data");
        }
        Order order = orderRepository.findById(id).orElseThrow(() -> new NotFoundException("Could not found order with id: " + id));
        User user = userRepository.findById(request.userId()).orElseThrow(() -> new NotFoundException("User not found"));
        List<Product> products = productRepository.findAllById(request.productIds());
        if (products.size() != request.productIds().size()) {
            throw new NotFoundException("One or more products not found");
        }
        order.setUser(user);
        order.setProducts(products);
        order.setOrderDate(request.orderDate());
        Order updatedOrder = orderRepository.save(order);

        NotificationDTO notificationDTO = new NotificationDTO("Updated order with id:", "order", updatedOrder.getId(), "update");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return mapOrderToOrderResponse(updatedOrder);
    }

    @Override
    public void deleteOrder(Long id) {
        if (!orderRepository.existsById(id)) {
            throw new NotFoundException("Could not found order with id " + id);
        }
        NotificationDTO notificationDTO = new NotificationDTO("Deleted order with id:", "order", id, "delete");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        orderRepository.deleteById(id);
    }

    @Override
    public List<OrderDTOs.OrderResponse> getOrders() {
        List<Order> orders = orderRepository.findAll();
        NotificationDTO notificationDTO = new NotificationDTO("Get all orders", "order", null, "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return orders.stream().map(this::mapOrderToOrderResponse).collect(Collectors.toList());

    }

    private OrderDTOs.OrderResponse mapOrderToOrderResponse(Order order) {
        UserDTOs.UserResponse userResponse = new UserDTOs.UserResponse(
                order.getUser().getId(),
                order.getUser().getFirstName(),
                order.getUser().getLastName(),
                order.getUser().getEmail(),
                order.getUser().getPhone()
        );

        List<ProductDTOs.ProductResponse> productResponses = order.getProducts().stream()
                .map(product -> new ProductDTOs.ProductResponse(
                        product.getId(),
                        product.getName(),
                        product.getPrice()
                ))
                .collect(Collectors.toList());

        return new OrderDTOs.OrderResponse(
                order.getId(),
                userResponse,
                productResponses,
                order.getOrderDate()
        );
    }
}
package com.example.todoapp.controller;

import org.example.todoapi.controllers.ProductApi;
import org.example.todoapi.dto.ProductDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import com.example.todoapp.assembler.ProductAssembler;
import com.example.todoapp.config.MessageProducer;
import com.example.todoapp.dto.NotificationDTO;
import com.example.todoapp.entity.Product;
import com.example.todoapp.repository.ProductRepository;
import com.example.todoapp.service.NotificationService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;


@RestController
@RequestMapping("/products")
public class ProductController implements ProductApi {

    private static final Logger logger = LoggerFactory.getLogger(ProductController.class);
    private final ProductRepository productRepository;
    private final ProductAssembler productAssembler;
    private final MessageProducer messageProducer;
    private final ObjectMapper objectMapper;
    private final NotificationService notificationService;

    public ProductController(ProductRepository productRepository,
                             ProductAssembler productAssembler,
                             MessageProducer messageProducer,
                             ObjectMapper objectMapper,
                             NotificationService notificationService) {
        this.productRepository = productRepository;
        this.productAssembler = productAssembler;
        this.messageProducer = messageProducer;
        this.objectMapper = objectMapper;
        this.notificationService = notificationService;
    }

    @Override
    public ProductDTOs.ProductResponse createProduct(ProductDTOs.ProductRequest request) {
        if (request == null || request.name() == null || request.name().isBlank() || request.price() == null || request.price() <= 0) {
            throw new InvalidArgumentException("Invalid product data");
        }
        Product product = new Product();
        product.setName(request.name());
        product.setPrice(request.price());
        Product savedProduct = productRepository.save(product);
        NotificationDTO notificationDTO = new NotificationDTO("Created product with id:", "product", savedProduct.getId(), "create");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new ProductDTOs.ProductResponse(savedProduct.getId(), savedProduct.getName(), savedProduct.getPrice());
    }

    @Override
    public ProductDTOs.ProductResponse getProduct(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found product with id " + id));
        NotificationDTO notificationDTO = new NotificationDTO("Get product with id:", "product", product.getId(), "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new ProductDTOs.ProductResponse(product.getId(), product.getName(), product.getPrice());

    }

    @Override
    public ProductDTOs.ProductResponse updateProduct(Long id, ProductDTOs.ProductRequest request) {
        if (request == null || request.name() == null || request.name().isBlank() || request.price() == null || request.price() <= 0) {
            throw new InvalidArgumentException("Invalid product data");
        }
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found product with id " + id));
        product.setName(request.name());
        product.setPrice(request.price());
        Product updatedProduct = productRepository.save(product);
        NotificationDTO notificationDTO = new NotificationDTO("Updated product with id:", "product", updatedProduct.getId(), "update");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new ProductDTOs.ProductResponse(updatedProduct.getId(), updatedProduct.getName(), updatedProduct.getPrice());
    }

    @Override
    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new NotFoundException("Could not found product with id " + id);
        }
        NotificationDTO notificationDTO = new NotificationDTO("Deleted product with id:", "product", id, "delete");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        productRepository.deleteById(id);
    }


    @Override
    public List<ProductDTOs.ProductResponse> getProducts() {
        List<Product> products = productRepository.findAll();
        NotificationDTO notificationDTO = new NotificationDTO("Get all products", "product", null, "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return products.stream().map(product -> new ProductDTOs.ProductResponse(product.getId(), product.getName(), product.getPrice())).collect(Collectors.toList());

    }
}
package com.example.todoapp.controller;

import org.example.todoapi.controllers.UserApi;
import org.example.todoapi.dto.UserDTOs;
import org.example.todoapi.exception.InvalidArgumentException;
import org.example.todoapi.exception.NotFoundException;
import com.example.todoapp.assembler.UserAssembler;
import com.example.todoapp.config.MessageProducer;
import com.example.todoapp.dto.NotificationDTO;
import com.example.todoapp.entity.User;
import com.example.todoapp.repository.UserRepository;
import com.example.todoapp.service.NotificationService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;


@RestController
@RequestMapping("/users")
public class UserController implements UserApi {
    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    private final UserRepository userRepository;
    private final UserAssembler userAssembler;
    private final MessageProducer messageProducer;
    private final ObjectMapper objectMapper;
    private final NotificationService notificationService;

    public UserController(UserRepository userRepository,
                          UserAssembler userAssembler,
                          MessageProducer messageProducer,
                          ObjectMapper objectMapper, NotificationService notificationService) {
        this.userRepository = userRepository;
        this.userAssembler = userAssembler;
        this.messageProducer = messageProducer;
        this.objectMapper = objectMapper;
        this.notificationService = notificationService;
    }

    @Override
    public UserDTOs.UserResponse createUser(UserDTOs.UserRequest request) {
        if (request == null || request.firstName() == null || request.firstName().isBlank() ||
                request.lastName() == null || request.lastName().isBlank() ||
                request.email() == null || request.email().isBlank() ||
                request.phone() == null || request.phone().isBlank()) {
            throw new InvalidArgumentException("Invalid user data");
        }
        User user = new User();
        user.setFirstName(request.firstName());
        user.setLastName(request.lastName());
        user.setEmail(request.email());
        user.setPhone(request.phone());
        User savedUser = userRepository.save(user);
        NotificationDTO notificationDTO = new NotificationDTO("Created user with id:", "user", savedUser.getId(), "create");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new UserDTOs.UserResponse(savedUser.getId(), savedUser.getFirstName(), savedUser.getLastName(), savedUser.getEmail(), savedUser.getPhone());
    }

    @Override
    public UserDTOs.UserResponse getUser(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found user with id " + id));
        NotificationDTO notificationDTO = new NotificationDTO("Get user with id:", "user", user.getId(), "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new UserDTOs.UserResponse(user.getId(), user.getFirstName(), user.getLastName(), user.getEmail(), user.getPhone());
    }

    @Override
    public UserDTOs.UserResponse updateUser(Long id, UserDTOs.UserRequest request) {
        if (request == null || request.firstName() == null || request.firstName().isBlank() ||
                request.lastName() == null || request.lastName().isBlank() ||
                request.email() == null || request.email().isBlank() ||
                request.phone() == null || request.phone().isBlank()) {
            throw new InvalidArgumentException("Invalid user data");
        }
        User user = userRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Could not found user with id " + id));
        user.setFirstName(request.firstName());
        user.setLastName(request.lastName());
        user.setEmail(request.email());
        user.setPhone(request.phone());
        User updatedUser = userRepository.save(user);
        NotificationDTO notificationDTO = new NotificationDTO("Updated user with id:", "user", updatedUser.getId(), "update");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return new UserDTOs.UserResponse(updatedUser.getId(), updatedUser.getFirstName(), updatedUser.getLastName(), updatedUser.getEmail(), updatedUser.getPhone());

    }

    @Override
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new NotFoundException("Could not found user with id " + id);
        }
        NotificationDTO notificationDTO = new NotificationDTO("Deleted user with id:", "user", id, "delete");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        userRepository.deleteById(id);
    }

    @Override
    public List<UserDTOs.UserResponse> getUsers() {
        List<User> users = userRepository.findAll();
        NotificationDTO notificationDTO = new NotificationDTO("Get all users", "user", null, "get");
        try {
            messageProducer.sendMessage(objectMapper.writeValueAsString(notificationDTO));
        } catch (JsonProcessingException e) {
            logger.error("Error during serialization of notification message", e);
            messageProducer.sendMessage("Error during serialization of notification message");
        }
        notificationService.sendNotification(notificationDTO.toString()); // Вызов sendNotification
        return users.stream().map(user -> new UserDTOs.UserResponse(user.getId(), user.getFirstName(), user.getLastName(), user.getEmail(), user.getPhone())).collect(Collectors.toList());

    }
}
package com.example.todoapp.datafetchers;

import com.example.todoapp.entity.Category;
import com.example.todoapp.repository.CategoryRepository;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

@DgsComponent
public class CategoryDataFetcher {

    private final CategoryRepository categoryRepository;

    @Autowired
    public CategoryDataFetcher(CategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    @DgsQuery
    public List<Category> categories(){
        return categoryRepository.findAll();
    }

    @DgsQuery
    public Optional<Category> category(@InputArgument Long id){
        return categoryRepository.findById(id);
    }


    @DgsMutation
    public Category createCategory(@InputArgument("category") Category category){
        return categoryRepository.save(category);
    }
    @DgsMutation
    public Category updateCategory(@InputArgument Long id, @InputArgument("category") Category category){
        if(!categoryRepository.existsById(id)){
            throw new RuntimeException("Category not found");
        }
        category.setId(id);
        return categoryRepository.save(category);
    }

    @DgsMutation
    public Boolean deleteCategory(@InputArgument Long id) {
        if (!categoryRepository.existsById(id)) {
            return false;
        }
        categoryRepository.deleteById(id);
        return true;
    }
}
package com.example.todoapp.datafetchers;

import com.example.todoapp.entity.Order;
import com.example.todoapp.entity.Product;
import com.example.todoapp.entity.User;
import com.example.todoapp.repository.OrderRepository;
import com.example.todoapp.repository.ProductRepository;
import com.example.todoapp.repository.UserRepository;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

@DgsComponent
public class OrderDataFetcher {
    private final OrderRepository orderRepository;
    private final UserRepository userRepository;
    private final ProductRepository productRepository;

    @Autowired
    public OrderDataFetcher(OrderRepository orderRepository, UserRepository userRepository, ProductRepository productRepository) {
        this.orderRepository = orderRepository;
        this.userRepository = userRepository;
        this.productRepository = productRepository;
    }

    @DgsQuery
    public List<Order> orders(){
        return orderRepository.findAll();
    }
    @DgsQuery
    public Optional<Order> order(@InputArgument Long id){
        return orderRepository.findById(id);
    }
    @DgsMutation
    public Order createOrder(@InputArgument("order") Map<String, Object> orderInput) {
        Long userId = Long.valueOf(orderInput.get("userId").toString());
        List<Long> productIds =  ((List<?>) orderInput.get("productIds")).stream()
                .filter(Objects::nonNull)
                .map(item -> {
                    if (item instanceof Number) {
                        return ((Number) item).longValue();
                    } else if(item instanceof String) {
                        try {
                            return Long.parseLong((String) item);
                        }
                        catch (NumberFormatException e){
                            throw new RuntimeException("Invalid product ID format: " + item, e);
                        }

                    }else {
                        throw new RuntimeException("Invalid product ID type: " + item.getClass().getName());
                    }
                }).collect(Collectors.toList());
        String orderDateString = orderInput.get("orderDate").toString();

        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
        List<Product> products = productRepository.findAllById(productIds);
        Order order = new Order();
        order.setUser(user);
        order.setProducts(products);
        order.setOrderDate(LocalDate.parse(orderDateString));
        return orderRepository.save(order);
    }
    @DgsMutation
    public Order updateOrder(@InputArgument Long id, @InputArgument("order")  Map<String, Object> orderInput){
        if(!orderRepository.existsById(id)){
            throw new RuntimeException("Order not found");
        }
        Long userId = Long.valueOf(orderInput.get("userId").toString());
        List<Long> productIds =  ((List<?>) orderInput.get("productIds")).stream()
                .filter(Objects::nonNull)
                .map(item -> {
                    if (item instanceof Number) {
                        return ((Number) item).longValue();
                    } else if(item instanceof String) {
                        try {
                            return Long.parseLong((String) item);
                        }
                        catch (NumberFormatException e){
                            throw new RuntimeException("Invalid product ID format: " + item, e);
                        }

                    }else {
                        throw new RuntimeException("Invalid product ID type: " + item.getClass().getName());
                    }
                }).collect(Collectors.toList());
        String orderDateString = orderInput.get("orderDate").toString();
        Order order = orderRepository.findById(id).orElseThrow(() -> new RuntimeException("Order not found"));
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
        List<Product> products = productRepository.findAllById(productIds);
        order.setUser(user);
        order.setProducts(products);
        order.setOrderDate(LocalDate.parse(orderDateString));
        return orderRepository.save(order);
    }
    @DgsMutation
    public Boolean deleteOrder(@InputArgument Long id){
        if(!orderRepository.existsById(id)){
            return false;
        }
        orderRepository.deleteById(id);
        return true;
    }
}
package com.example.todoapp.datafetchers;

import com.example.todoapp.entity.Product;
import com.example.todoapp.repository.ProductRepository;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

@DgsComponent
public class ProductDataFetcher {
    private final ProductRepository productRepository;

    @Autowired
    public ProductDataFetcher(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    @DgsQuery
    public List<Product> products(){
        return productRepository.findAll();
    }
    @DgsQuery
    public Optional<Product> product(@InputArgument Long id){
        return productRepository.findById(id);
    }

    @DgsMutation
    public Product createProduct(@InputArgument("product") Product product){
        return productRepository.save(product);
    }
    @DgsMutation
    public Product updateProduct(@InputArgument Long id, @InputArgument("product") Product product){
        if(!productRepository.existsById(id)){
            throw new RuntimeException("Product not found");
        }
        product.setId(id);
        return productRepository.save(product);
    }

    @DgsMutation
    public Boolean deleteProduct(@InputArgument Long id) {
        if (!productRepository.existsById(id)) {
            return false;
        }
        productRepository.deleteById(id);
        return true;
    }
}
package com.example.todoapp.datafetchers;

import com.example.todoapp.entity.User;
import com.example.todoapp.repository.UserRepository;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

@DgsComponent
public class UserDataFetcher {

    private final UserRepository userRepository;

    @Autowired
    public UserDataFetcher(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @DgsQuery
    public List<User> users(){
        return userRepository.findAll();
    }

    @DgsQuery
    public Optional<User> user(@InputArgument Long id){
        return userRepository.findById(id);
    }
    @DgsMutation
    public User createUser(@InputArgument("user") User user){
        return userRepository.save(user);
    }

    @DgsMutation
    public User updateUser(@InputArgument Long id, @InputArgument("user") User user){
        if(!userRepository.existsById(id)){
            throw new RuntimeException("User not found");
        }
        user.setId(id);
        return userRepository.save(user);
    }
    @DgsMutation
    public Boolean deleteUser(@InputArgument Long id) {
        if (!userRepository.existsById(id)) {
            return false;
        }
        userRepository.deleteById(id);
        return true;
    }
}
package com.example.todoapp.dto;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class NotificationDTO {
    private String message;
    private String entityType;
    private Long entityId;
    private String operationType;

    public NotificationDTO(String message, String entityType, Long entityId, String operationType) {
        this.message = message;
        this.entityType = entityType;
        this.entityId = entityId;
        this.operationType = operationType;
    }
}
package com.example.todoapp.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "categories")
@Data
@NoArgsConstructor
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
package com.example.todoapp.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToMany
    @JoinTable(name = "order_products",
            joinColumns = @JoinColumn(name = "order_id"),
            inverseJoinColumns = @JoinColumn(name = "product_id"))
    private List<Product> products;

    private LocalDate orderDate;
}
package com.example.todoapp.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
}
package com.example.todoapp.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;

}
package com.example.todoapp.exception;

public class CategoryNotFoundException extends RuntimeException{
    public CategoryNotFoundException(Long id){
        super("Could not found category with id " + id);
    }
}
package com.example.todoapp.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler({UserNotFoundException.class, ProductNotFoundException.class, OrderNotFoundException.class, CategoryNotFoundException.class})
    public ResponseEntity<?> notFoundException(RuntimeException ex){
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
package com.example.todoapp.exception;

public class OrderNotFoundException extends RuntimeException {
    public OrderNotFoundException(Long id){
        super("Could not found order with id " + id);
    }
}
package com.example.todoapp.exception;

public class ProductNotFoundException extends RuntimeException{
    public ProductNotFoundException(Long id){
        super("Could not found product with id " + id);
    }
}
package com.example.todoapp.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(Long id){
        super("Could not found user with id " + id);
    }
}
package com.example.todoapp.model;

import lombok.Data;

import java.time.LocalDate;
import java.util.List;

@Data
public class OrderRequest {
    private Long userId;
    private List<Long> productIds;
    private LocalDate orderDate;
}
package com.example.todoapp.repository;

import com.example.todoapp.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CategoryRepository extends JpaRepository<Category, Long> {
}
package com.example.todoapp.repository;

import com.example.todoapp.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<Order, Long> {
}
package com.example.todoapp.repository;

import com.example.todoapp.entity.Product;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductRepository extends JpaRepository<Product, Long> {
}
package com.example.todoapp.repository;

import com.example.todoapp.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}
package com.example.todoapp.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    private final SimpMessagingTemplate template;

    @Autowired
    public NotificationService(SimpMessagingTemplate template) {
        this.template = template;
    }

    public void sendNotification(String message) {
        template.convertAndSend("/topic/notifications", message);
    }
}
package com.example.todoapp;

import com.example.todoapp.config.RabbitMQConfig;
import com.example.todoapp.service.NotificationService;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodoAppApplication {
	private final static String queueName = RabbitMQConfig.queueName;
	@Autowired
	private NotificationService notificationService;

	public static void main(String[] args) {
		SpringApplication.run(TodoAppApplication.class, args);
	}
}
schema.graphqls:
type Query {
    categories: [Category]
    category(id: ID!): Category
    products: [Product]
    product(id: ID!): Product
    users: [User]
    user(id: ID!): User
    orders: [Order]
    order(id: ID!): Order
}

type Mutation {
    createCategory(category: CategoryInput!): Category
    updateCategory(id: ID!, category: CategoryInput!): Category
    deleteCategory(id: ID!): Boolean
    createProduct(product: ProductInput!): Product
    updateProduct(id: ID!, product: ProductInput!): Product
    deleteProduct(id: ID!): Boolean
    createUser(user: UserInput!): User
    updateUser(id: ID!, user: UserInput!): User
    deleteUser(id: ID!): Boolean
    createOrder(order: OrderInput!): Order
    updateOrder(id: ID!, order: OrderInput!): Order
    deleteOrder(id: ID!): Boolean

}

type Category {
    id: ID!
    name: String
}

input CategoryInput {
    name: String!
}

type Product {
    id: ID!
    name: String
    price: Float
}

input ProductInput {
    name: String!
    price: Float!
}

type User {
    id: ID!
    firstName: String
    lastName: String
    email: String
    phone: String
}

input UserInput {
    firstName: String!
    lastName: String!
    email: String!
    phone: String!
}
type Order {
    id: ID!
    user: User
    products: [Product]
    orderDate: String
}
input OrderInput {
    userId: ID!
    productIds: [ID!]!
    orderDate: String!
}
websocket.html:
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Notifications</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
</head>
<body>
<div id="notifications"></div>
<script>
    var socket = new SockJS('http://localhost:8080/ws'); // поменяйте порт на свой
    var stompClient= Stomp.over(socket);
    stompClient.connect({}, function(frame) {
        console.log('Connected: ' + frame);
        stompClient.subscribe('/topic/notifications', function(notification) {
            var notifications = document.getElementById('notifications');
            var message = document.createElement('p');
            message.appendChild(document.createTextNode(notification.body));
            notifications.appendChild(message);
        });
    });
</script>
</body>
</html>
application.properties:
spring.application.name=todo-app
server.port=8080

# PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/web_service_db
spring.datasource.username=postgres
spring.datasource.password=sql
spring.jpa.hibernate.ddl-auto=update

# RabbitMQ Configuration
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

pom.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.4.0</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example</groupId>
	<artifactId>todo-app</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>todo-app</name>
	<description>ToDo application with REST, GraphQL, RabbitMQ and WebSocket</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-rest-hal-explorer</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.30</version>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webflux</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.amqp</groupId>
			<artifactId>spring-rabbit-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-websocket</artifactId>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.example.todoapi</groupId>
			<artifactId>todo-api</artifactId>
			<version>1.0-SNAPSHOT</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-netty-shaded</artifactId>
			<version>1.62.2</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-protobuf</artifactId>
			<version>1.62.2</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-stub</artifactId>
			<version>1.62.2</version>
		</dependency>
		<dependency>
			<groupId>com.netflix.graphql.dgs</groupId>
			<artifactId>graphql-dgs-spring-boot-starter</artifactId>
			<version>9.2.2</version>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-graphql</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>javax.annotation</groupId>
			<artifactId>javax.annotation-api</artifactId>
			<version>1.3.2</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.xolstice.maven.plugins</groupId>
				<artifactId>protobuf-maven-plugin</artifactId>
				<version>0.6.1</version>
				<configuration>
					<protocArtifact>com.google.protobuf:protoc:3.25.2:exe:windows-x86_64</protocArtifact>
					<pluginId>grpc-java</pluginId>
					<pluginArtifact>io.grpc:protoc-gen-grpc-java:1.62.2:exe:windows-x86_64</pluginArtifact>
					<protoSourceRoot>src/main/proto</protoSourceRoot>
				</configuration>
				<executions>
					<execution>
						<goals>
							<goal>compile</goal>
							<goal>compile-custom</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>1.18.30</version>
						</path>
					</annotationProcessorPaths>
					<compilerArgs>
						<arg>-parameters</arg>
					</compilerArgs>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.1.2</version>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>